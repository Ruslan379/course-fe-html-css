console.log(
    '%c 2.Throttle ',
    'color: white; background-color: #D33F49',
);

//! Chatty events
console.warn("Chatty events​:");
//? ✳️ Досить часто необхідно обробити зміну розміру вікна,
//? скрол, переміщення миші або текстове введення користувача.
//? Це може бути сортування колекції і відображення результатів,
//? анімація елемента, маніпуляції з DOM-деревом та інше.
//? Все це покращує UX (user experience), але, на жаль,
//? має велике навантаження на браузер, оскільки обробники подій
//? спрацьовують надто часто.
//? Такі події неофіційно називають «chatty events».


//! Подія "scroll"
console.warn('Подія "scroll​:');
//? ✳️ Наприклад, якщо додати слухача події до скролу, 
//? то під час прокручування сторінки мишкою 
//? можна викликати близько 30 подій на секунду. 
//? Повільне прокручування (свайп) у смартфоні може викликати 
//? до 100 подій на секунду. 
//? Якщо обробник події скролу виконує важкі обчислення 
//? та інші DOM-маніпуляції, гарантовано 
//? виникнуть проблеми з продуктивністю.
const output = document.querySelector(".output");
let scrollEventCounter = 0;

document.addEventListener("scroll", () => {
    scrollEventCounter += 1;
    output.textContent = scrollEventCounter;
    // console.log("scrollEventCounter:", scrollEventCounter); //!
});
console.log("-----------------------------------------------------------");


//! Throttle і Debounce
console.warn("Throttle і Debounce​:");
//? ✴️ Throttle і Debounce - це два схожих, 
//? але різних за поведінкою прийоми, 
//? що дозволяють контролювати кількість разів, 
//? яку ми дозволяємо виконувати функції з часом. 
//? Використовуємо їх реалізацію з бібліотеки Lodash.

//! Throttle
console.warn(`Throttle​​: \n ${((window.location.href).split('/')).slice(0, -2).join('/') + '/'}${"lesson-FE4_02/images/throttle.png"}`);
//? ✴️ Прийом throttle контролює кількість разів,
//? яку функція може бути викликана протягом певного проміжку часу.
//? Тобто дозволяє викликати функцію не частіше
//? одного разу за N мілісекунд, гарантуючи її регулярне виконання.
//? ✳️ Використовуючи throttle, ми не контролюємо,
//? як часто браузер буде генерувати події.
//? Ми всього-на-всього беремо контроль
//? над частотою виконання функції обробника події.
//? ✳️ Реалізація з бібліотеки Lodash
//? очікує першим аргументом функцію,
//? яку необхідно «загальмувати»,
//? а другим - кількість мілісекунд.
//? Повертає нову функцію для передачі в слухач події.
// document.addEventListener("scroll",() => {
//     console.log("Виклик обробника прокрутки кожні 300ms");
// });
    
document.addEventListener(
    "scroll",
    _.throttle(() => {
        console.log("Виклик обробника прокрутки кожні 300ms");
    }, 300)
);
console.log("-----------------------------------------------------------");
